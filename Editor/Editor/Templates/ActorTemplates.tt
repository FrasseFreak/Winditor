<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Newtonsoft.Json"#>
// <#@ assembly name="$(ProjectDir)/../WCommon/lib/GameFormatReader.dll"#>
<#@ assembly name="$(TargetPath)"#>
<#@ import namespace="Newtonsoft.Json" #>
<#@ import namespace="WindEditor" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="GameFormatReader.Common" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".cs" #>

<#

var ProjectDirPath = Host.ResolveAssemblyReference("$(ProjectDir)");
var TemplatePath = ProjectDirPath + "resources/templates/MapEntityData";

#>
using GameFormatReader.Common;
using OpenTK;
using System.ComponentModel;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using WindEditor.ViewModel;

namespace WindEditor
{
<#

string EscapeIdentifier(string input)
{
	return Regex.Replace(input, @"[^a-z0-9_]", "", RegexOptions.IgnoreCase);
}
string EscapeStringLiteral(string input)
{
	string output = Regex.Replace(input, @"([""\\])", @"\$1"); // Escape quotes and backslashes
	output = Regex.Replace(output, @"([\0\a\b\f\n\r\t\v])", "", RegexOptions.IgnoreCase);
	return "\"" + output + "\"";
}

// We sometimes have duplicate templates to handle loading from the file, so we'll not generate duplicate classes.
List<string> usedClassNames = new List<string>();
foreach (var file in Directory.GetFiles(TemplatePath))
{
    ActorDataDescriptor descriptor = JsonConvert.DeserializeObject<ActorDataDescriptor>(File.ReadAllText(file));
	string className = descriptor.ClassName;
	string parentClassName = string.IsNullOrEmpty(descriptor.ParentClassOverride) ? "Actor" : descriptor.ParentClassOverride;
#>
	// AUTO-GENERATED, MODIFICATIONS TO THIS FILE WILL BE LOST
	public partial class <#= className #> : <#= parentClassName #>
	{
		// Auto-Generated Properties from Templates
<#
		// We skip these fields as they're pulled out in the load function and we don't want duplicate properties.
		var skippedFields = new List<string>(new []{"Position", "XRotation", "YRotation", "ZRotation", "XScale", "YScale", "ZScale"});
		foreach(var field in descriptor.Fields)
		{
			if(skippedFields.Contains(field.FieldName.Replace(" ", "")))
				continue; 

			string fieldName = EscapeIdentifier(field.FieldName);
			string valueSource = String.IsNullOrEmpty(field.ValueSource) ? "Parameters" : field.ValueSource;
			string privateFieldName = "m_" + fieldName;
			string overrideName = field.FieldName == "Name" ? "override" : "";
			string categoryName = field.CategoryName != null ? field.CategoryName : "Misc.";
			string bitMaskHex;
			string valueSourceType;
			if (valueSource.Contains("Auxillary")) {
				bitMaskHex = String.Format("0x{0:X4}", field.BitMask);
				valueSourceType = "short";
			} else {
				bitMaskHex = String.Format("0x{0:X8}", field.BitMask);
				valueSourceType = "int";
			}
			string dataType;
			switch (field.DataType)
			{
				case "Integer":
					dataType = "int";
					break;
				case "Boolean":
					dataType = "bool";
					break;
				case "Path":
					dataType = "Path_v2";
					break;
				case "Exit":
					dataType = "ExitData";
					break;
				case "Enum":
					dataType = fieldName + "Enum";

					if (field.EnumValues == null)
					{
						throw new ArgumentException($"Field \"{field.FieldName}\" in file \"{file}\" specifies Enum data type, but does not list any EnumValues");
					}
#>
		public enum <#= dataType #>
		{
<#
					foreach (var item in field.EnumValues)
					{
						string sanitizedValue = item.Value.Replace(" ", "_");
						sanitizedValue = EscapeIdentifier(sanitizedValue);
#>
			<#= sanitizedValue #> = <#= item.Key #>,
<#
					}
#>
		}

<#

					break;
				case "ItemID":
					dataType = "ItemID";
					break;
				default:
					throw new ArgumentException($"Invalid data type \"{field.DataType}\" specified for field \"{field.FieldName}\" in file \"{file}\"");
					break;
			}
#>
<#		 // We hide padding and other fields that the user doesn't need to see/change.
		if(!field.IsHidden)
		{
#>
		[WProperty("<#= categoryName #>", "<#= field.FieldName #>", true<#= string.IsNullOrEmpty(field.ToolTip) ? "" : ", " + EscapeStringLiteral(field.ToolTip) #>)]
<# 
		}
#>
		<#= overrideName #>public <#= dataType #> <#= fieldName #>
		{ 
			get
			{
				int value_as_int = (int)((<#= valueSource #> & <#= bitMaskHex #>) >> <#= field.BitShift #>);
<#
				switch (field.DataType)
				{
					case "Integer":
#>
				return value_as_int;
<#
						break;
					case "Boolean":
#>
				return Convert.ToBoolean(value_as_int);
<#
						break;
					case "Path":
					case "Exit":
#>
				if (value_as_int == 0xFF) { return null; }
				WDOMNode cur_object = this;
				while (cur_object.Parent != null)
				{
					cur_object = cur_object.Parent;
				}
				List<<#= dataType #>> list = cur_object.GetChildrenOfType<<#= dataType #>>();
				if (value_as_int >= list.Count) { return null; }
				return list[value_as_int];
<#
						break;
					case "Enum":
					case "ItemID":
#>
				return (<#= dataType #>)value_as_int;
<#
						break;
				}
#>
			}

			set
			{
<#
				switch (field.DataType)
				{
					case "Integer":
#>
				int value_as_int = value;
<#
						break;
					case "Boolean":
#>
				int value_as_int = Convert.ToInt32(value);
<#
						break;
					case "Path":
					case "Exit":
#>
				WDOMNode cur_object = this;
				while (cur_object.Parent != null)
				{
					cur_object = cur_object.Parent;
				}
				List<<#= dataType #>> list = cur_object.GetChildrenOfType<<#= dataType #>>();
				int value_as_int = list.IndexOf(value);
<#
						break;
					case "Enum":
					case "ItemID":
#>
				int value_as_int = (int)value;
<#
						break;
				}
#>
				<#= valueSource #> = (<#= valueSourceType #>)(<#= valueSource #> & ~<#= bitMaskHex #> | (value_as_int << <#= field.BitShift #> & <#= bitMaskHex #>));
				OnPropertyChanged("<#=fieldName#>");
			}
		}

<#		}#>
		// Constructor
		public <#= className #>(FourCC fourCC, WWorld world) : base(fourCC, world)
		{
			
		}
	}

<#
}
#>

} // namespace WindEditor
